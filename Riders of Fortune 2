            
            /*_________---======================---_________.
            |                  : ROF 2 :                    |
            |                                               |
            |   > - - - - Game by Mattia Iudean - - - - <   |
            |                                               |
            |   COP 2335                                    |
            |                                               |
            l________..__________________________________..*/

#include <iostream>
#include <vector>
#include <iomanip>
#include <time.h>
#include <conio.h>
#include <windows.h>
#include <stdlib.h>
#include <cmath>
#include <fstream>
#include "Player.h"

using namespace std;

/*___________________________________________________________________________.
|                                                                            |
|                           Initialization                                   |
L___________________________________________________________________________*/

                       // - - - constants - - - \\

const int ROWS = 8;
const int COLUMNS = 8;
const int WEAPONS = 5;
int const base = 5;
char gameBoard[ROWS][COLUMNS];

          // - - - player, weapon, and game save structs/misc - - - \\

Player player;

struct Weapon fists, crossbow, flail,
    broadSword, morningStar, holyStaff;

vector<Weapon> weaponCollection;

fstream savedGame;

struct GameSave
{
    int HP = 100, positionX = 0, positionY = 0, turn = 1, XP = 1,
        bagSize = 5, invSlot = 0, invItem = 0, maxSlot = 0;

    string equippedWeapon = "Fists";

    std::vector<Weapon> weaponVect{ fists };

    string inventory[base];

    bool playerAlignment = true;

    char gameBoard[ROWS][COLUMNS];
};

                      // - - - inventory - - - \\

string* addSpaces(string[], int);
void addItem();

string* bag = new string[base];

int invCounter, newSize, currentSize, invItem, maxCounter = 0;

void setInventory();
void setCurrentSize();
void setCounter();
void setMaxCounter(int);
void showInventory();

                   // - - - initializing colors - - - \\

HANDLE screen = GetStdHandle(STD_OUTPUT_HANDLE);

                  // - - - initializing variables - - - \\

int positionX = 0;
int positionY = 0;
int counter = 0;

bool startOfGame = true;
bool gameLost = false;
bool gameWon = false;

bool running = true;
bool gotChoice = false;

bool isItem = false, isMonster = false, isEmpty = false;

bool gotRelic = false, gotItem = false, alreadyDismounted = false;

bool gotCrossbow = false, gotFlail = false,
     gotBroadSword = false, gotStar = false, 
     gotStaff = false;

string magicRelic = "Magic Relic";
string potion = "Potion of Health";

 /*___________________________________________________________________________.
 |                                                                            |
 |                         Function Prototypes                                |
 L___________________________________________________________________________*/

                        // - - - utility - - - \\

void coloredText(string, WORD);
int randomNumber(int, int);

                        // - - - UX & UI - - - \\

int getChoice(); // menu for selecting next move
void dismount(); // function that controls combat & space interactions
void changePosition(); 
void combat();

void graveyard();
void cathedral();
void well();

void invalidAction();
void titleScreen();

                        // - - - initialization - - - \\

void initializeWeapons();
void assignSpaces();
void setMap();

                          // - - - game save - - - \\

void populateGameState(GameSave&); // initializing gamestate struct w/ game data
void loadState(GameSave&); // initializing game with gamestate struct data
void saveGame();  // save game to a file
void loadGame();  // load game from a file
void gameOver();  // end of the game menu

int main()
{
    // initializing random number generator

    srand(time(NULL));

    setInventory();

    assignSpaces();

    initializeWeapons();

    setMap();

    titleScreen();

    printMap();

    while (running)
    {
        while (!gotChoice)
        {
            int choice = getChoice();

            if (choice >= 0 && choice < 6)
            {
                switch (choice)
                {
                case 1:
                    changePosition();
                    break;

                case 2:
                    dismount();
                    break;

                case 3:
                    saveGame();
                    coloredText("\nGame saved!\n\n", 2);

                    coloredText("\nPress any key...\n\n", 14);

                    _getch();

                    running = false;
                    gotChoice = true;
                    break;

                case 4:
                    showInventory();
                    break;
                }
            }

            else
            {
                invalidAction();
            }

            if (gameWon || gameLost)
            {
                gameOver();
            }
        }
    }
    
    delete[] bag;

    return 0;
}

void dismount()
{
    if (!alreadyDismounted)
    {
        if (isMonster)
        {
            combat();
        }

        if (isEmpty)
        {
            // threw in these two random interactions for empty spaces, each of
            // which has an equal chance of happening. player gets a small
            // amount of XP or HP.

            cout << "\n You take some time to rest and gather your thoughts.\n";

            int randomBuff = randomNumber(1, 2);
            
            double futureHP = player.getHP() + (player.getHP() * 0.08);

            static_cast<int>(futureHP);

            if (futureHP < 100 && randomBuff == 1)
            {
                    if (player.getAlignment())
                    {
                        SetConsoleTextAttribute(screen, 9);
                    }

                    else if (!player.getAlignment())
                    {
                        SetConsoleTextAttribute(screen, 12);
                    }

                    cout << "+ " << futureHP << " HP!\n\n";

                    player.setHP(futureHP);
                
            }

            else if (randomBuff == 2)
            {
                double randomXP = player.getXP() * 0.1;

                static_cast<int>(randomXP);

                cout << "+ " << randomXP << " XP!\n\n";

                player.setXP(player.getXP() + randomXP);
            }

            coloredText("\nPress any key...\n\n", 14);

            _getch();
        }

        alreadyDismounted = true;
    }

    else
    {
        cout << "\n You've already dismounted!\n\n";
    }

    gotChoice = false;
}

void setMaxCounter(int itemNumber)
{
    if (itemNumber % 5 == 0)
    {
        maxCounter = itemNumber + 5;
    }
}

void initializeWeapons()
{
    // weapon objects are initialized with their values, and random spaces that are either a 
    // monster, item, or empty are replaced with weapons.

    fists.attack = 2;
    fists.name = "Fists";

    crossbow.attack = 3;
    crossbow.name = "Crossbow";

    flail.attack = 5;
    flail.name = "Flail";

    broadSword.attack = 8;
    broadSword.name = "Broad Sword";

    morningStar.attack = 13;
    morningStar.name = "Morning Star";

    holyStaff.attack = 21;
    holyStaff.name = "Holy Staff";

    int x, y = 0;
    int count = 0;

    bool xValid = false;
    bool yValid = false;

    bool crossBowAssigned = false;
    bool flailAssigned = false;
    bool broadSwordAssigned = false;
    bool morningStarAssigned = false;
    bool holyStaffAssigned = false;
    bool assigned = false;

    // loop is restricted to reiterating only as many times as there are weapons

    while (count !=  WEAPONS)
    {
        int randomX = 0;
        int randomY = 0;
        xValid = false;
        yValid = false;

        randomX = randomNumber(0, 7);
        randomY = randomNumber(0, 7);

        if (gameBoard[randomX][randomY] == 'm' || gameBoard[randomX][randomY] == 'i' || gameBoard[randomX][randomY] == '.')
        {
            if (randomX == 0 || randomY == 0 || randomX == 7 || randomY == 7)
            {
                x = randomX;
                y = randomY;

                if (!crossBowAssigned)
                {
                    crossbow.posX = x;
                    crossbow.posY = y;

                    gameBoard[x][y] = 'c';

                    crossBowAssigned = true;

                    count++;
                }

                if (!flailAssigned && gameBoard[x][y] != 'c')
                {
                    flail.posX = x;
                    flail.posY = y;

                    gameBoard[x][y] = 'f';

                    flailAssigned = true;

                    count++;
                }

                if (!broadSwordAssigned && gameBoard[x][y] != 'f' &&
                     gameBoard[x][y] != 'c')
                {
                    broadSword.posX = x;
                    broadSword.posY = y;

                    gameBoard[x][y] = 'b';

                    broadSwordAssigned = true;

                    count++;
                }

                if (!morningStarAssigned && gameBoard[x][y] != 'b' && 
                     gameBoard[x][y] != 'f' && gameBoard[x][y] != 'c')
                {
                    morningStar.posX = x;
                    morningStar.posY = y;

                    gameBoard[x][y] = 'M';

                    morningStarAssigned = true;

                    count++;
                }

                if (!holyStaffAssigned && gameBoard[x][y] != 'M' && 
                     gameBoard[x][y] != 'b' && gameBoard[x][y] != 'f' && 
                     gameBoard[x][y] != 'c')
                {
                    holyStaff.posX = x;
                    holyStaff.posY = y;

                    holyStaffAssigned = true;
                    assigned = true;

                    count++;
                }
            }

        }
    }  

    // default weapon 

    weaponCollection.push_back(fists);
}

void populateGameState(GameSave &myGameSave)
{
    int collectionSize = myGameSave.weaponVect.size();

    myGameSave.HP = player.getHP();
    myGameSave.positionX = player.getPosX();
    myGameSave.positionY = player.getPosY();
    myGameSave.turn = player.getTurn();
    myGameSave.XP = player.getXP();

    myGameSave.playerAlignment = player.getAlignment();
    myGameSave.equippedWeapon = player.getWeaponName();
    
    myGameSave.bagSize = currentSize;
    myGameSave.invSlot = invCounter;
    myGameSave.invItem = invItem;
    myGameSave.maxSlot = maxCounter;

    myGameSave.inventory[currentSize];
    myGameSave.weaponVect = weaponCollection;

    for (int i = 0; i < currentSize; i++)
    {
        myGameSave.inventory[i] = bag[i];
    }

    for (int x = 0; x < ROWS; x++)
    {
        for (int y = 0; y < COLUMNS; y++)
        {
            myGameSave.gameBoard[x][y] = gameBoard[x][y];
        }
    }

    cout << " " << myGameSave.HP << "\n";
    cout << " " << myGameSave.positionX << "\n";
    cout << " " << myGameSave.positionY << "\n";
    cout << " " << myGameSave.turn << "\n";
    cout << " " << myGameSave.XP << "\n";

    for (int i = 0; i < collectionSize; i++)
    {
        cout << " " << myGameSave.weaponVect[i].name;
    }

    cout << "\n" << myGameSave.playerAlignment << "\n";
    cout << myGameSave.equippedWeapon << "\n";
} 

void loadState(GameSave &loadedSave)
{
    int collectionSize = loadedSave.weaponVect.size();

    player.setHP(loadedSave.HP);
    player.setPosX(loadedSave.positionX);
    player.setPosY(loadedSave.positionY);
    player.setTurn(loadedSave.turn);
    player.setXP(loadedSave.XP);

    player.setAlignment(loadedSave.playerAlignment);
    player.setWeaponName(loadedSave.equippedWeapon);

    currentSize = loadedSave.bagSize;
    invCounter = loadedSave.invSlot;
    invItem = loadedSave.invItem;
    maxCounter = loadedSave.maxSlot;

    weaponCollection = loadedSave.weaponVect;

    for (int i = 0; i < currentSize; i++)
    {
        bag[i] = loadedSave.inventory[i];
    }

    for (int x = 0; x < ROWS; x++)
    {
        for (int y = 0; y < COLUMNS; y++)
        {
            gameBoard[x][y] = loadedSave.gameBoard[x][y];
        }
    }

    cout << " HP: " << loadedSave.HP << "\n";
    cout << " X: " << loadedSave.positionX << "\n";
    cout << " Y: " << loadedSave.positionY << "\n";
    cout << " Turn: " << loadedSave.turn << "\n";
    cout << " XP: " << loadedSave.XP << "\n";

    for (int i = 0; i < collectionSize; i++)
    {
        cout << " " << loadedSave.weaponVect[i].name;
    }

    cout << "\n Alignment: " << loadedSave.playerAlignment << "\n ";
    cout << " Weapon: " << loadedSave.equippedWeapon << "\n ";
    cout << "Inventory size: " << loadedSave.bagSize << "\n ";

}

    // GameSave object is created and the current game data is input into the
    // struct.

void saveGame()
{
    GameSave justSaved;

    savedGame.open("SaveData.txt", ios::out | ios::in);

    populateGameState(justSaved);

    savedGame.write(reinterpret_cast<char*>(&justSaved),
        sizeof(justSaved));

    savedGame.close();

    gotChoice = false;
}

    // GameSave object is created and the saved data is loaded into the object,
    // which then loads all the information into all the respective variables.

    // unfortunately doesn't work and every time i try to run it the correct
    // information is displayed but it's followed by an access violation

void loadGame()
{
    GameSave loadedGame;

    savedGame.open("SaveData.txt", ios:: out | ios::in);

    savedGame.read(reinterpret_cast<char*>(&loadedGame),
        sizeof(loadedGame));

    loadState(loadedGame);

    savedGame.close();

    gotChoice = false;
}

    /*____________________________________________________________________________________.
    |                                                                                     |
    |   to simplify the color changing process and prevent it from being stretched out    |                                                                               
    |   over too many lines, i created this function that changes the font color, outputs |                                                                                 
    |   a string, then changes it back to the default. for outputting variables, i simply |
    |   use the classic SetConsoleTextAttribute                                           |                                     
    |                                                                                     |
    L ___________________________________________________________________________________*/

void coloredText(string message, WORD textColor)
{
    WORD defaultColor = 7;

    SetConsoleTextAttribute(screen, textColor);

    cout << message;

    SetConsoleTextAttribute(screen, defaultColor);
}

void invalidAction()
{
    coloredText("\nPlease enter a valid digit.\n", 12);
}

void titleScreen()
{
    int choice = 1;

    cout << "/_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-/\n" << "^" << setw(90) << "^\n";

    cout << "^" << setw(63);

    coloredText("WELCOME TO RIDERS OF FORTUNE 2!", 14);

    cout << setw(27) << "^\n";

    cout << "^" << setw(70);

    coloredText("You are Yarra, an adventurer trapped in a dungeon", 14);

    cout << setw(20) << "^\n"
        << "^" << setw(60);

    coloredText("ready to fight your way out.", 14);

    cout << setw(30) << "^\n"
        << "^";

    cout << setw(90) << "^\n" << "/_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-/\n\n"
         << " 1. ";
    
    coloredText("Start new game", 14);
    
    cout << "\n 2. ";
    
    coloredText("Load game\n", 14);

    cin >> choice;

    cout << "\n";

    if (choice == 2)
    {
        loadGame();
    }
}

int getChoice()
{
    //_______________________________________
    
    // turn

    int turn = player.getTurn();
    int* turnPointer;

    turnPointer = &turn;

    coloredText(" Turn: ", 14); 
    
    cout << *turnPointer << "\n";

    // _______________________________________

    // player HP

    int playerHP = player.getHP();

    coloredText(" HP: ", 14);

    if (playerHP > 79)
    {
        SetConsoleTextAttribute(screen, 2);
    }

    else if (playerHP > 59 && playerHP < 80)
    {
        SetConsoleTextAttribute(screen, 14);
    }

    else if (playerHP > 39 && playerHP < 60)
    {
        SetConsoleTextAttribute(screen, 14);
    }

    else if (playerHP < 40)
    {
        SetConsoleTextAttribute(screen, 12);
    }

    cout << playerHP << "\n";

    SetConsoleTextAttribute(screen, 7);

    // _______________________________________

    // alignment

    bool alignment;
    alignment = player.getAlignment();


    coloredText(" Alignment: ", 14);

    if (alignment == true)
    {
        coloredText("GOOD\n", 9);
    }

    else
    {
        coloredText("EVIL\n", 12);
    }

    // _______________________________________

    // coordinates

    int xCoord, yCoord;
    xCoord = player.getPosX();
    yCoord = player.getPosY();

    coloredText(" Coordinates: ", 14);
        
    cout << xCoord << ", " << yCoord << "\n";

    // ______________________________________

    // xp

    coloredText(" XP: ", 14); 

    cout << player.getXP() << "\n";

    // ______________________________________

    // weapon

    coloredText(" Equipped weapon: ", 14);
        
    cout << player.getWeaponName() << "\n";

    // ______________________________________
    
    // inventory

    //showInventory();

    if (player.getAlignment() == true)
    {
        coloredText("\n-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-\n", 9);
    }

    else
    {
        coloredText("\n-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-\n", 12);
    }

    /*____________________________________________________________________________________.
    |                                                                                     |
    |   the player's choice is taken is a char so that the '>' and '<' can be properly    |
    |   input, after which i use a switch to turn the number into an int  -- menuNumber.  |
    |   menuNumber is returned to the choice switch in int main(), which launches a       |
    |   specific function based on it.                                                    |
    |                                                                                     |
    L ___________________________________________________________________________________*/

    char menuChoice;
    int menuNumber = 0;

    cout << "\n => 1 - Roll\n => 2 - Dismount\n => 3 - Save Game\n";
    cout << " => 4 - Open inventory\n";

    if (currentSize > 5)
    {
        cout << "=> > - Next inventory page\n";

        if (maxCounter > 5)
        {
            cout << "=> < - Previous inventory page\n";
        }
    }

    if (isMonster && !alreadyDismounted)
    {
        coloredText("\nYou've encountered an enemy!\n", 12);

        cout << "Dismount to attack.\n";
    }

    cout << "\n";

    cin >> menuChoice;

    cout << "\n";

    if (menuChoice == '>')
    {
        invItem += 5;
    }

    else if (menuChoice == '<')
    {
        invItem -= 5;
    }

    else
    {
        switch (menuChoice)
        {
        case '1':
            menuNumber = 1;
            break;

        case '2':
            menuNumber = 2;
            break;

        case '3':
            menuNumber = 3;
            break;

        case '4':
            menuNumber = 4;
            break;

        case '5':
            menuNumber = 5;
            break;
        }
    }

    gotChoice = true;

    turn++;

    player.setTurn(turn);

    return menuNumber;
};

void showInventory()
{

    /*___________________________________________________________________________.
    |                                                                            |
    |   the way i dealt with making the inventory have pages is that i use       |
    |   maxCounter as a maximum to a range of 5 items displayed. if the          |
    |   bag expands, the number of pages expands as well. invItem is basically   |
    |   pointing to the item that is being printed, and the maxCounter changes   |
    |   only if invItem reaches 5, 10, or any other multiple of 5. that way, the |
    |   range of 5 items is shifted up. this way, depending on player input      |
    |   the pages may go both forward and backward as many times as necessary    |
    |   with no data being lost.                                                 |
    L __________________________________________________________________________*/

    setMaxCounter(invItem);

    coloredText("\n        Inventory: \n", 2);

    for (invItem; invItem < maxCounter; invItem++)
    {
        cout << "  " << invItem + 1 << ". " << bag[invItem] << "\n";
    }

    int pageNumber = maxCounter / 5;
    int totalPages = currentSize / 5;

    cout << "        Page " << pageNumber << " of " << totalPages << "\n";

    invItem -= 5;

} 

void combat()
{
    int monsterDead = false;
    int collectionSize = weaponCollection.size();
    string weaponImmunity;

        while (!monsterDead)
        {
            int chosenWeapon;
            int playerXP = player.getXP();
            int monsterHP, multiplier, playerAttack,
                combatChoice, damageRoll;
            bool usedPotion = false;
            bool monsterImmune = false;

            // monster's HP scales with the player's XP, so if the player has
            // 1 XP, the monster may have between 1 and 5 HP, if they have 2,
            // it has between 1 and 10, and so on.

            multiplier = playerXP * 5;

            monsterHP = randomNumber(1, multiplier);

            // weapon monster is immune to is decided by randomly choosing one
            // of the weapons in the player's collection. if the player only
            // has one weapon, the interaction does not play. the player is 
            // prompted to switch the weapon that the monster is immune to.

            int randomWeapon = randomNumber(1, collectionSize);

            weaponImmunity = weaponCollection[randomWeapon - 1].name;

            if (collectionSize > 1)
            {
                cout << "\nMonster is immune to " << weaponImmunity << "\n";
            }

            cout << "\n1. ";

            coloredText("Attack", 12);

            cout << "\n2. ";

            coloredText("Use item", 2);

            cout << "\n\n";

            cin >> combatChoice;

            switch (combatChoice)
            {
            case 1:

                coloredText("\n Weapon collection: \n ", 2);

                for (int i = 0; i < collectionSize; ++i)
                {
                    cout << i + 1 << ". " << weaponCollection[i].name << "\n ";
                }

                cout << "\n => Input weapon number to equip.\n\n";

                cin >> chosenWeapon;

                player.setWeapon(weaponCollection[chosenWeapon - 1]);

                SetConsoleTextAttribute(screen, 2);

                cout << "\n Equipped the " << player.getWeaponName();

                SetConsoleTextAttribute(screen, 7);

                cout << "\n > You now have " << player.getWeaponAttack()
                     << " damage.\n";

                while (!monsterDead)
                {
                    int playerHP = player.getHP();

                    SetConsoleTextAttribute(screen, 2);

                    cout << "\n Player HP: " << playerHP;

                    SetConsoleTextAttribute(screen, 12);

                    cout << "\n Monster HP: " << monsterHP << "\n";

                    SetConsoleTextAttribute(screen, 7);

                    // Player can roll a 10 max to ensure they don't one shot 
                    // the monsters without a powerful weapon. The monster's 
                    // attack is a random number with its HP as a max.
                    // As it is wounded, it becomes weaker. As the player gets
                    // stronger, the monsters do as well, although that comes 
                    // with the price of weaker monsters in early game.

                    damageRoll = randomNumber(1, 10);
                    playerAttack = player.weaponDamage(player.getWeapon(), damageRoll);

                    cout << "\n > Rolled a " << damageRoll << ". You attack for " 
                         << playerAttack << "!\n";

                    if (weaponImmunity == player.getWeaponName())
                    {
                        monsterImmune = true;
                    }

                    if (collectionSize == 1)
                    {
                        monsterImmune = false;
                    }

                    if (!monsterImmune)
                    {
                        monsterHP -= playerAttack;
                    }

                    else
                    {
                        while (monsterImmune)
                        {
                            cout << "\n Monster is immune to the " << weaponImmunity << "!\n";

                            cout << " Choose another weapon: \n ";

                            for (int i = 0; i < collectionSize; ++i)
                            {
                                cout << i + 1 << ". " << weaponCollection[i].name << "\n ";
                            }

                            cin >> chosenWeapon;

                            player.setWeapon(weaponCollection[chosenWeapon - 1]);

                            if (weaponImmunity != player.getWeaponName())
                            {
                                monsterImmune = false;

                                SetConsoleTextAttribute(screen, 2);

                                cout << "\n Equipped the " << player.getWeaponName();

                                SetConsoleTextAttribute(screen, 7);

                                cout << "\n > You now have " << player.getWeaponAttack()
                                    << " damage.\n";
                            }
                        }
                    }

                    if (monsterHP <= 0)
                    {
                        int currentXP = player.getXP();
                        double addedXP;
                        int newXP;

                        addedXP = currentXP * 0.3;

                        addedXP += 0.7;

                        static_cast<int>(addedXP);

                        newXP = addedXP + currentXP;

                        static_cast<int>(newXP);

                        player.setXP(newXP);

                        coloredText("\n You have slain the monster!\n", 2);

                        cout << "+ " << addedXP << " XP!\n\n";

                        monsterDead = true;
                        alreadyDismounted = true;
                    }

                    else
                    {
                    SetConsoleTextAttribute(screen, 2);

                    cout << "\n Player HP: " << playerHP;

                    SetConsoleTextAttribute(screen, 12);

                    cout << "\n Monster HP: " << monsterHP << "\n";

                    SetConsoleTextAttribute(screen, 7);

                    int monsterAttack = randomNumber(1, monsterHP);

                    cout << "\n > Monster attacks you for " << monsterAttack 
                         << "!\n";

                    playerHP -= monsterAttack;

                    player.setHP(playerHP);
                    }

                    if (playerHP <= 0)
                    {
                        gameLost = true;
                    }
                }
                break;

            case 2:

                // if player's HP is under 100, a for loop iterates through
                // each item in their bag until it finds a potion, after which
                // it replaces the spot with an empty space and applies it to 
                // the player's health.

                if (player.getHP() < 100)
                {
                    for (int i = 0; i < currentSize; i++)
                    {
                        if (bag[i] == potion)
                        {
                            bag[i] = "         -";

                            player.useItem(potion);

                            cout << "\n You drink the potion and very quickly"
                                 << " begin to feel its effects!\n + 10 HP\n";

                            usedPotion = true;
                        }
                    }
                }

                else
                {
                    cout << "\nYou are already at max health!\n\n";
                }
                break;
            }
        }

        printMap();
}

void printMap()
{
    // printMap() takes the elements stored within the array and prints them
    // out.

    cout << "\n";

    setMap();

    for (int x = 0; x < ROWS; x++)
    {
        for (int y = 0; y < COLUMNS; y++)
        {
            cout << " ";

            if (gameBoard[x][y] == '.')
            {
                SetConsoleTextAttribute(screen, 8);
            }
            
            else if (gameBoard[x][y] == 'i')
            {
                SetConsoleTextAttribute(screen, 7);
            }

            else if (gameBoard[x][y] == 'm')
            {
                SetConsoleTextAttribute(screen, 12);
            }

            else if (gameBoard[x][y] == 'P')
            {
                if (player.getAlignment())
                {
                    SetConsoleTextAttribute(screen, 31);
                }

                else
                {
                    SetConsoleTextAttribute(screen, 71);
                }
            }

            else if (gameBoard[x][y] == 'G' || gameBoard[x][y] == 'C' ||
                     gameBoard[x][y] == 'W' || gameBoard[x][y] == 'E')
            {
                SetConsoleTextAttribute(screen, 14);
            }

            else if (gameBoard[x][y] == 'c' || gameBoard[x][y] == 'f'  ||
                     gameBoard[x][y] == 'b' || gameBoard[x][y] == 'M'  ||
                     gameBoard[x][y] == 'h')
            {
                SetConsoleTextAttribute(screen, 2);
            }

            cout << gameBoard[x][y];

            SetConsoleTextAttribute(screen, 7);
        }

        cout << endl;
    }
    cout << "\n";
}

void setMap()
{
    // whereas printMap() outputs the map, setMap() sets each element of the 
    // array.
    
    // declaring all the set locations

    gameBoard[0][4] = 'W';            
    gameBoard[7][4] = 'W';            

    gameBoard[0][7] = 'C';
    gameBoard[7][7] = 'C';

    gameBoard[7][0] = 'G';
    gameBoard[3][7] = 'G';

    gameBoard[3][0] = 'E';

    //Use two loops to draw the game board. If the passed in player position matches
    //a position, place a P on it.
    for (int x = 0; x < ROWS; x++)
    {
        for (int y = 0; y < COLUMNS; y++)
        {
            //The board representation will be drawn with * only if is the outer paths
            //of the 2D Array

            if (x == player.getPosX() && y == player.getPosY())
            {
                gameBoard[x][y] = 'P';
            }

            else if (x == crossbow.posX && y == crossbow.posY)
            {
                gameBoard[x][y] = 'c';
            }

            else if (x == flail.posX && y == flail.posY)
            {
                gameBoard[x][y] = 'f';
            }

            else if (x == broadSword.posX && y == broadSword.posY)
            {
                gameBoard[x][y] = 'b';
            }

            else if (x == morningStar.posX && y == morningStar.posY)
            {
                gameBoard[x][y] = 'M';
            }

            else if (x == holyStaff.posX && y == holyStaff.posY)
            {
                gameBoard[x][y] = 'h';
            }

            else if (x == 5 && y == 3 || x == 4 && y == 3 || x == 3 && y == 3 ||
                     x == 2 && y == 3 || x == 2 && y == 4 || x == 2 && y == 5 ||
                     x == 3 && y == 5 || x == 4 && y == 4 || x == 5 && y == 5)
            {
                gameBoard[x][y] = 'X';
            }
        }
    }
}

void assignSpaces()
{
    for (int x = 0; x < ROWS; x++)
    {
        for (int y = 0; y < COLUMNS; y++)
        {
            // the assignment of monsters, items, and empty spaces is randomized
            // and each has a top number of possible instances, which i tried
            // to keep even among them all

                int number = randomNumber(1, 3);
                int monsters, items, empty;

                monsters = 0;
                items = 0;
                empty = 0;

                if (y == 0 || y == 7 || x == 0 || x == 7)
                {
                    if (number == 1 && monsters < 10)
                    {
                        gameBoard[x][y] = 'm';

                        if (x == 0 && y == 0)
                        {
                            isMonster = true;
                        }
                    }

                    else if (number == 2 && items < 9)
                    {
                        gameBoard[x][y] = 'i';

                        if (x == 0 && y == 0)
                        {
                            isItem = true;
                        }
                    }

                    else if (number == 3 && empty < 9)
                    {
                        gameBoard[x][y] = '.';

                        if (x == 0 && y == 0)
                        {
                            isEmpty = true;
                        }
                    }
                }

                else
                {
                    gameBoard[x][y] = ' ';
                }
        }
    }
}

void changePosition() 
{
    /* _______________________________________________________________________.
    | >--- movement                                                           |
    |                                                                         |
    | Roll a d6 to find out how many spaces, store the future coordinates in  |
    | futureX and futureY, then compare them to the next space. There is an   |
    | interaction that takes place with all the randomized spaces. Program    |
    | also checks if the space they are on is an item, monster, or empty      |
    | in order to make sure the old letter remains. After everything is done, |
    | futureX and futureY are plugged into the player class' coordinates.     |
    L________________________________________________________________________*/

    int spacesToMove, futureX, futureY;

    spacesToMove = 0;
    alreadyDismounted = false;

    spacesToMove = randomNumber(1, 6);

    SetConsoleTextAttribute(screen, 9);

    cout << "\n" << "Rolled a " << spacesToMove << "\n";

    SetConsoleTextAttribute(screen, 7);
    

    if (isMonster)
    {
        gameBoard[player.getPosX()][player.getPosY()] = 'm';

        isMonster = false;
    }

    if (isEmpty)
    {
        gameBoard[player.getPosX()][player.getPosY()] = '.';

        isEmpty = false;
    }

    if (isItem)
    {
        gameBoard[player.getPosX()][player.getPosY()] = 'i';
        
        isItem = false;
    }

    if (gameBoard[player.getPosX()][player.getPosY()] == 'c')
    {
        if (gotStaff)
        {
            gameBoard[player.getPosX()][player.getPosY()] = '.';
        }
    }

    if (gameBoard[player.getPosX()][player.getPosY()] == 'f')
    {
        if (gotFlail)
        {
            gameBoard[player.getPosX()][player.getPosY()] = '.';
        }
    }

    if (gameBoard[player.getPosX()][player.getPosY()] == 'b')
    {
        if (gotBroadSword)
        {
            gameBoard[player.getPosX()][player.getPosY()] = '.';
        }
    }

    if (gameBoard[player.getPosX()][player.getPosY()] == 'M')
    {
        if (gotStar)
        {
            gameBoard[player.getPosX()][player.getPosY()] = '.';
        }
    }

    if (gameBoard[player.getPosX()][player.getPosY()] == 'h')
    {
        if (gotStaff)
        {
            gameBoard[player.getPosX()][player.getPosY()] = '.';
        }
    }

    //position is in the first row and moving right
    if (positionX == 0 && positionY != 7) 
    {
        if (positionY + spacesToMove >= COLUMNS) 
        {
            spacesToMove = spacesToMove - (COLUMNS - (positionY + 1));

            positionY = 7;
        }
        else {
            positionY = positionY + spacesToMove;
            spacesToMove = 0;
        }
    }

    //position is last column and moving down 
    if (positionY == 7 && positionX != 7) {
        if (positionX + spacesToMove >= ROWS) {
            spacesToMove = spacesToMove - (ROWS - (positionX + 1));

            positionX = 7;
        }
        else {
            positionX = positionX + spacesToMove;
            spacesToMove = 0;
        }
    }

    //position is on last row and moving left
    if (positionX == 7 && positionY != 0) {
        if ((COLUMNS - (positionY + 1)) + spacesToMove >= COLUMNS) {
            spacesToMove = spacesToMove - (positionY);
            positionY = 0;
        }
        else {
            positionY = positionY - spacesToMove;
            positionY;
            spacesToMove = 0;
        }
    }

    //position is on first column and moving up
    if (positionY == 0 && positionX != 0) {
        if ((ROWS - (positionX + 1)) + spacesToMove >= ROWS) {
            spacesToMove = spacesToMove - (positionX);

            positionX = 0;
        }
        else {
            positionX = positionX - spacesToMove;
            spacesToMove = 0;
        }
    }

    futureX = positionX;
    futureY = positionY;

    player.setPosX(positionX);
    player.setPosY(positionY);

    if (gameBoard[futureX][futureY] == 'W')
    {
        well();
    }

    else if (gameBoard[futureX][futureY] == 'C')
    {
        cathedral();
    }

    else if (gameBoard[futureX][futureY] == 'G')
    {
        graveyard();
    }

    else if (gameBoard[futureX][futureY] == 'i')
    {
        addItem();
        isItem = true;
    }

    // if the player lands on a spot that has a weapon, they pick it up
    // and are given the option of equipping it on the spot. if they already 
    // have it, the spot is made empty and a different interaction plays out.
    

    else if (gameBoard[futureX][futureY] == 'c' ||
        gameBoard[futureX][futureY] == 'f' ||
        gameBoard[futureX][futureY] == 'b' ||
        gameBoard[futureX][futureY] == 'M' ||
        gameBoard[futureX][futureY] == 'h')
    {
        cout << "\n You come across a ";

        if (gameBoard[futureX][futureY] == 'c')
        {
            coloredText("Crossbow", 2);

            if (gotCrossbow)
            {
                cout << " but you already have one, so you keep walking.\n";
            }

            if (!gotCrossbow)
            {
                cout << " and stash it in your bag.\n";

                weaponCollection.push_back(crossbow);

                gotCrossbow = true;
            }
        }

        else if (gameBoard[futureX][futureY] == 'f')
        {
            coloredText("Flail", 2);

            if (gotFlail)
            {
                cout << " but you already have one, so you keep walking.\n";
            }

            if (!gotFlail)
            {
                cout << " and stash it in your bag.\n";

                weaponCollection.push_back(flail);

                gotFlail = true;
            }
        }

        else if (gameBoard[futureX][futureY] == 'b')
        {
            coloredText("Broad Sword", 2);

            if (gotBroadSword)
            {
                cout << " but you already have one, so you keep walking.\n";
            }

            if (!gotBroadSword)
            {
                cout << " and stash it in your bag.\n";

                weaponCollection.push_back(broadSword);

                gotBroadSword = true;
            }
        }

        else if (gameBoard[futureX][futureY] == 'M')
        {
            coloredText("Morning Star", 2);

            if (gotStar)
            {
                cout << " but you already have one, so you keep walking.\n";
            }

            if (!gotStar)
            {
                cout << " and stash it in your bag.\n";

                weaponCollection.push_back(morningStar);

                gotStar = true;
            }
        }

        else if (gameBoard[futureX][futureY] == 'h')
        {
            coloredText("Holy Staff", 2);

            if (gotStaff)
            {
                cout << " but you already have one, so you keep walking.\n";
            }

            if (!gotStaff)
            {
                cout << " and stash it in your bag.\n";

                weaponCollection.push_back(holyStaff);

                gotStaff = true;
            }
        }

        coloredText("\n Press 1 to equip or 2 to continue...\n", 14);

        int num;

        cin >> num;

        if (num == 1)
        {
            player.setWeapon(weaponCollection.back());

            cout << "\n Equipped ";

            SetConsoleTextAttribute(screen, 14);

            cout << player.getWeaponName();
        }
    }

    else if (gameBoard[futureX][futureY] == 'm')
    {
        isMonster = true;
    }

    else if (gameBoard[futureX][futureY] == '.')
    {
        isEmpty = true;
    }

    else if (gameBoard[futureX][futureY] == 'E')
    {
        if (!gotRelic)
        {
            player.useItem(magicRelic);
        }

        else if (gotRelic)
        {
            player.useItem(magicRelic);

            gameWon = true;
        }
    }

    gotChoice = false;

    cout << "\n";

    printMap();
}

    // the graveyard and cathedral are basically identical. i add 0.8 in case
    // the player's HP is 1.
void graveyard()
{
    bool currentAlignment = player.getAlignment();
    int playerHP = player.getHP();

    if (currentAlignment == false)
    {
        double addedHP = playerHP * 0.2;

        double newPlayerHP = addedHP + playerHP;

        double convertedHP = newPlayerHP + 0.8;

        static_cast<int>(addedHP);
        static_cast<int>(convertedHP);

        if (convertedHP <= 100 && convertedHP >= 1)
        {
            player.setHP(convertedHP);
        }

        else if (convertedHP > 100)
        {
            player.setHP(100);
        }

        cout << "\n Prowling the graveyard grounds, you feel the ghoulish power"
             << " flowing freely.\n\n";
        
        SetConsoleTextAttribute(screen, 11);                   

        cout << "+ " << addedHP << " HP!\n";                

        SetConsoleTextAttribute(screen, 7);

        coloredText("\nPress any key...\n\n", 14);

        _getch();
    }

    else
    {
        double subtractedHP = playerHP * 0.2;
        double newPlayerHP = playerHP - subtractedHP;

        double convertedHP = newPlayerHP + 0.8;

        static_cast<int>(subtractedHP);
        static_cast<int>(convertedHP);

        player.setHP(newPlayerHP);

        cout << "\n Tense, you stride down the dirt path in between the graves."
             << "\n Out of nowhere, a ghoul lunges at you.\n";
                                         
        SetConsoleTextAttribute(screen, 12);
                                                                  
        cout << "- " << subtractedHP << " HP!\n";                

        SetConsoleTextAttribute(screen, 7);

        coloredText("\nPress any key...\n\n", 14);

        _getch();

        if (newPlayerHP < 1)
        {
            cout << " This cursed place has snuffed out your light.\n";

            gameLost = true;
        }
    }
}

void cathedral()
{
    bool currentAlignment = player.getAlignment();
    int playerHP = player.getHP();

    if (currentAlignment == true)
    {
        double addedHP = playerHP * 0.2;

        double newPlayerHP = addedHP + playerHP;

        double convertedHP = newPlayerHP + 0.8;

        static_cast<int>(addedHP);
        static_cast<int>(convertedHP);

        if (convertedHP <= 100 && convertedHP >= 1)
        {
            player.setHP(convertedHP);

            cout << "\n You step into the cathedral and approach the altar"
                 << " inside the massive chamber. The Gods smile upon you"
                 << " today, Yarra.\n";

            SetConsoleTextAttribute(screen, 11);

            cout << "  + " << addedHP << " HP!\n";

            SetConsoleTextAttribute(screen, 7);

            coloredText("\nPress any key...\n\n", 14);

            _getch();
        }

        else if (convertedHP > 100)
        {
            player.setHP(100);
        }
    }

    else
    {
        double subtractedHP = playerHP * 0.2;
        double newPlayerHP = playerHP - subtractedHP;

        double convertedHP = newPlayerHP + 0.8;

        static_cast<int>(subtractedHP);
        static_cast<int>(convertedHP);

        if (newPlayerHP >= 1)
        {
            cout << "\n Your dark aura is felt by the priests within the\n"
                 << " cathedral, who alert the templars. Wounded in the"
                 << "\n ambush, you attempt to flee.\n";

            SetConsoleTextAttribute(screen, 12);

            cout << "  - " << subtractedHP << " HP!\n\n";

            SetConsoleTextAttribute(screen, 7);

            player.setHP(newPlayerHP);

            coloredText("\nPress any key...\n\n", 14);

            _getch();
        }

        else
        {
            cout << " Tripping over a rock, you find yourself face to face"
                 << " with one of the templars.\n The last thing you see is the"
                 << " cold visor of his helmet \n as the sword plunges into your"
                 << "heart.\n You've fallen at the hands of the forces of light.\n\n";
                
            gameLost = true;
        }
    }
}

void well()
{
    int newXP = 0;

    newXP += 2;

    player.setXP(newXP);

    cout << "\n You reflect on your journey and make some startling revelations.\n";

    cout << " You are now ";

    bool currentAlignment = player.getAlignment();

    if (currentAlignment == true)
    {
        player.setAlignment(false);
        coloredText("evil.\n", 12);
    }

    else
    {
        player.setAlignment(true);
        coloredText("good\n", 11);
    }

    coloredText("\nPress any key...\n\n", 14);

    _getch();
}

int randomNumber(int low, int high)
{
    // random number generator

    return (rand() % (high - low + 1)) + low;
}

void setInventory()
{
    setCounter();

    setCurrentSize();

    for (int x = 0; x < currentSize; x++)
    {
        bag[x] = "         -";                                                 
    }
}

    // Initializing the values of the global variables used
    // within the inventory

void setCounter()
{
    invCounter = 0;
}

void setCurrentSize()
{
    currentSize = 5;
}

string* addSpaces(string originalArray[], int originalSize) 
{
    //Declare our new array using a pointer
    string* arr = nullptr;

    //Calculate our new array size
    newSize = originalSize + 5;

    arr = new string[newSize];

    //Loop through the elements in the original array and copy them to the new array

    for (int cnt = 0; cnt < originalSize; cnt++) 
    {
        arr[cnt] = originalArray[cnt];
    }

    for (int i = 0; i < newSize; i++)
    {
        if (arr[i] == " ")
        {
            arr[i] = "         -";
        }
    }
    
    currentSize = newSize;

    return arr;
}

void addItem()
{
    // invCounter is the number of the slot within the inventory that most 
    // recently got an item.

    gotItem = false;

    int odds = randomNumber(1, 2);
    int oldCounter;

    if (invCounter != 0)
    {
        if (invCounter % 5 == 0)
        {
            bag = addSpaces(bag, currentSize);

            cout << "\nPassing through a market, you find a saddlebag that ";
            
            cout << "is larger than\n";

            cout << "the one you currently have.\n\n";

            SetConsoleTextAttribute(screen, 14);

            cout << "+ 5 storage. Total is now " << currentSize << "\n\n";

            SetConsoleTextAttribute(screen, 7);

            coloredText("Press any key...\n\n", 14);

            _getch();
        }
    }

    if (bag[invCounter] == "         -")
    {
        // player has a 50% chance of getting the Magic Relic, 
        // which can only be found once.

        if (!gotItem)
        {
            bag[invCounter] = potion;

            gotItem = true;
        }

        if (odds == 1)
        {
            if (!gotRelic)
            {
                bag[invCounter] = magicRelic;

                gotRelic = true;
            }
        }
    }

    // invCounter is the number of the slot that is being accessed,
    // and 1 is added every time an item is added. therefore, oldCounter
    // is necessary to store the value of the previous slot which holds
    // the item that was just added.

    invCounter++;

    oldCounter = invCounter - 1;

    SetConsoleTextAttribute(screen, 14);

    cout << "\nAdded ";

    SetConsoleTextAttribute(screen, 7);

    cout << bag[oldCounter];
    
    SetConsoleTextAttribute(screen, 14);
    
    cout << " to bag\n";

    cout << invCounter;
    
    SetConsoleTextAttribute(screen, 7);
    
    cout << " of ";
    
    SetConsoleTextAttribute(screen, 14);
    
    cout << currentSize;
    
    SetConsoleTextAttribute(screen, 7);
    
    cout << " slots filled\n";

    coloredText("Press any key...\n\n", 14);

    _getch();

}

void gameOver()
{
    if (gameWon)
    {
        cout << "\n And thus, your adventure draws to an end as you exit the"
            << " dungeon and take in the fresh air.\n";
            
        coloredText("Congratulations, you've won the game!\n", 2);
    }

    else if (gameLost)
    {
        cout << "\n Unable to best the dungeon and fight your way out, you find"
            << " yourself perishing in its depths.\n";

        coloredText("GAME OVER\n\n", 2);
    }

    coloredText("\nPress any key...\n\n", 14);

    _getch();

    running = false;
    gotChoice = true;
}


